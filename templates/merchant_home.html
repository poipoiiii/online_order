{% extends "base.html" %}

{% block title %}å•†å®¶ç®¡ç† - ç½‘ä¸Šè®¢é¤ç³»ç»Ÿ{% endblock %}

{% block extra_css %}
<style>
    @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}
    .dashboard-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin: 20px 0;
    }
    .dashboard-card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 25px;
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        text-align: center;
        transition: all 0.3s ease;
    }
    .dashboard-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 15px 40px rgba(0,0,0,0.15);
    }
    .card-icon {
        font-size: 48px;
        margin-bottom: 15px;
    }
    .card-title {
        font-size: 16px;
        color: #666;
        margin-bottom: 10px;
    }
    .card-value {
        font-size: 32px;
        font-weight: 700;
        color: #2c3e50;
    }
    .dish-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        margin: 20px 0;
    }
    .dish-card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .dish-name {
        color: #2c3e50;
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 8px;
    }
    .dish-price {
        color: #e74c3c;
        font-size: 20px;
        font-weight: 700;
        margin: 10px 0;
    }
    .section-title {
        color: white;
        margin: 30px 0 20px 0;
        font-size: 24px;
        font-weight: 600;
    }
</style>
{% endblock %}

{% block content %}
<div id="appmerchant">
    <div>
        <h1 style="color: white; margin-bottom: 30px; font-size: 32px; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
            ğŸª å•†å®¶ç®¡ç†é¢æ¿
        </h1>
        
        <!-- åœ¨ç»Ÿè®¡å¡ç‰‡éƒ¨åˆ† -->
        <div class="dashboard-cards">
            <!-- ç°æœ‰ç»Ÿè®¡å¡ç‰‡ -->
            <div class="dashboard-card">
                <div class="card-icon">ğŸ½ï¸</div>
                <div class="card-title">èœå“æ•°é‡</div>
                <div class="card-value">[[ dishes.length ]]</div>
            </div>
            
            <div class="dashboard-card">
                <div class="card-icon">ğŸ“Š</div>
                <div class="card-title">åœ¨å”®èœå“</div>
                <div class="card-value">[[ availableDishesCount ]]</div>
            </div>
            
            <div class="dashboard-card">
                <div class="card-icon">ğŸ’°</div>
                <div class="card-title">ä»Šæ—¥è®¢å•</div>
                <div class="card-value">[[ todayOrdersCount ]]</div>
            </div>
            
            <!-- æ–°è®¢å•é€šçŸ¥å¡ç‰‡ -->
            <div v-if="hasNewOrders" class="dashboard-card" style="background: linear-gradient(135deg, #ff6b6b, #ee5a52); color: white; animation: pulse 2s infinite;">
                <div class="card-icon">ğŸ””</div>
                <div class="card-title">æ–°è®¢å•æé†’</div>
                <div class="card-value">[[ unreadOrdersCount ]]</div>
                <div style="margin-top: 10px;">
                    <el-button type="primary" @click="navigateTo('/merchant/orders/'); markOrdersAsRead();" size="small">
                        æŸ¥çœ‹è®¢å•
                    </el-button>
                </div>
            </div>
            
            <div v-else-if="pendingOrdersCount > 0" class="dashboard-card" style="background: linear-gradient(135deg, #ffa726, #ff9800); color: white;">
                <div class="card-icon">â³</div>
                <div class="card-title">å¾…å¤„ç†è®¢å•</div>
                <div class="card-value">[[ pendingOrdersCount ]]</div>
                <div style="margin-top: 10px;">
                    <el-button type="primary" @click="navigateTo('/merchant/orders/')" size="small">
                        ç«‹å³å¤„ç†
                    </el-button>
                </div>
            </div>
        </div>
                
        <!-- èœå“ç®¡ç† -->
        <div style="margin-top: 40px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 class="section-title">ğŸ“‹ èœå“ç®¡ç†</h2>
                <el-button type="primary" @click="showAddDialog = true">
                    <i class="el-icon-plus"></i> æ·»åŠ èœå“
                </el-button>
            </div>
            
            <div class="dish-grid">
                <div v-for="dish in dishes" :key="dish.id" class="dish-card">
                    <div class="dish-name">[[ dish.name ]]</div>
                    <div class="dish-price">Â¥[[ dish.price ]]</div>
                    <div style="color: #6c757d; margin-bottom: 15px; font-size: 14px;">
                        [[ dish.description ]]
                    </div>
                    <div style="margin-bottom: 15px;">
                        <el-tag :type="dish.is_available ? 'success' : 'info'" size="small">
                            [[ dish.is_available ? 'ä¸Šæ¶' : 'ä¸‹æ¶' ]]
                        </el-tag>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <el-button 
                            size="small" 
                            :type="dish.is_available ? 'warning' : 'success'"
                            @click="toggleDishStatus(dish)"
                        >
                            [[ dish.is_available ? 'ä¸‹æ¶' : 'ä¸Šæ¶' ]]
                        </el-button>
                        <el-button size="small" type="danger" @click="deleteDish(dish.id)">
                            åˆ é™¤
                        </el-button>
                    </div>
                </div>
            </div>
            
            <div v-if="dishes.length === 0" style="text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.8);">
                <el-empty description="æš‚æ— èœå“">
                    <el-button type="primary" @click="showAddDialog = true">æ·»åŠ ç¬¬ä¸€ä¸ªèœå“</el-button>
                </el-empty>
            </div>
        </div>
    </div>

<!-- æ·»åŠ èœå“å¯¹è¯æ¡† -->
<el-dialog v-model="showAddDialog" title="æ·»åŠ æ–°èœå“" width="500px">
    <el-form :model="newDish" :rules="dishRules" ref="dishFormRef" label-width="80px">
        <el-form-item label="èœå“åç§°" prop="name">
            <el-input v-model="newDish.name" placeholder="è¯·è¾“å…¥èœå“åç§°"></el-input>
        </el-form-item>
        <el-form-item label="ä»·æ ¼" prop="price">
            <el-input-number 
                v-model="newDish.price" 
                :min="0" 
                :step="0.01" 
                :precision="2"
                style="width: 100%;"
                placeholder="è¯·è¾“å…¥ä»·æ ¼"
            ></el-input-number>
        </el-form-item>
        <el-form-item label="æè¿°">
            <el-input 
                v-model="newDish.description" 
                type="textarea" 
                :rows="3"
                placeholder="è¯·è¾“å…¥èœå“æè¿°"
            ></el-input>
        </el-form-item>
    </el-form>
    
    <template #footer>
        <span class="dialog-footer">
            <el-button @click="showAddDialog = false">å–æ¶ˆ</el-button>
            <el-button type="primary" @click="addDish" :loading="addLoading">
                æ·»åŠ 
            </el-button>
        </span>
    </template>
</el-dialog>
</div>


<script>
    const { } = Vue;
    const { } = ElementPlus;

const appmerchant = createApp({
    delimiters: ['[[', ']]'],
    setup() {
        const dishes = ref([]);
        const orders = ref([]);
        const showAddDialog = ref(false);
        const addLoading = ref(false);
        const dishFormRef = ref(null);
        
        // é€šçŸ¥ç›¸å…³çŠ¶æ€
        const hasNewOrders = ref(false);
        const unreadOrdersCount = ref(0);
        const lastOrderCount = ref(0);

        const newDish = ref({
            name: '',
            price: 0,
            description: ''
        });

        const dishRules = {
            name: [
                { required: true, message: 'è¯·è¾“å…¥èœå“åç§°', trigger: 'blur' }
            ],
            price: [
                { required: true, message: 'è¯·è¾“å…¥ä»·æ ¼', trigger: 'blur' },
                { type: 'number', min: 0, message: 'ä»·æ ¼å¿…é¡»å¤§äº0', trigger: 'blur' }
            ]
        };

        // è®¡ç®—å±æ€§
        const availableDishesCount = computed(() => {
            return dishes.value.filter(dish => dish.is_available).length;
        });

        const todayOrdersCount = computed(() => {
            const today = new Date().toDateString();
            return orders.value.filter(order => {
                const orderDate = new Date(order.created_at).toDateString();
                return orderDate === today;
            }).length;
        });

        const pendingOrdersCount = computed(() => {
            return orders.value.filter(order => order.status === 'pending').length;
        });

        // åŠ è½½èœå“
        const loadDishes = async () => {
            try {
                const response = await fetch('/api/merchant/dishes/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({ action: 'list' })
                });
                
                const data = await response.json();
                if (data.dishes) {
                    dishes.value = data.dishes;
                }
            } catch (error) {
                console.error('åŠ è½½èœå“é”™è¯¯:', error);
                ElMessage.error('åŠ è½½èœå“å¤±è´¥');
            }
        };

        // åŠ è½½å•†å®¶è®¢å•
        const loadMerchantOrders = async () => {
            try {
                //console.log("1111111111111")
                const response = await fetch('/api/merchant/orders/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({})
                });
                
                const data = await response.json();
                if (data.success && data.orders) {
                    // æ£€æµ‹æ–°è®¢å•
                    const currentOrderCount = data.orders.length;
                    if (lastOrderCount.value > 0 && currentOrderCount > lastOrderCount.value) {
                        const newOrderCount = currentOrderCount - lastOrderCount.value;
                        showNewOrderNotification(newOrderCount);
                    }
                    
                    orders.value = data.orders;
                    lastOrderCount.value = currentOrderCount;
                }
            } catch (error) {
                console.error('åŠ è½½è®¢å•é”™è¯¯:', error);
            }
        };

        // æ˜¾ç¤ºæ–°è®¢å•é€šçŸ¥
        const showNewOrderNotification = (newCount) => {
            hasNewOrders.value = true;
            unreadOrdersCount.value += newCount;
            
            // æ˜¾ç¤ºå¼¹çª—é€šçŸ¥
            ElNotification({
                title: 'ğŸ‰ æ–°è®¢å•é€šçŸ¥',
                message: `æ‚¨æœ‰ ${newCount} ä¸ªæ–°è®¢å•ï¼Œè¯·åŠæ—¶å¤„ç†ï¼`,
                type: 'success',
                duration: 5000,
                position: 'top-right',
                onClick: () => {
                    navigateTo('/merchant/orders/');
                    markOrdersAsRead();
                }
            });
            
            // æµè§ˆå™¨é€šçŸ¥
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('ğŸ• æ–°è®¢å•æé†’', {
                    body: `æ‚¨æœ‰ ${newCount} ä¸ªæ–°è®¢å•å¾…å¤„ç†`,
                    icon: '/static/images/logo.png'
                });
            } else if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        };

        // è¯·æ±‚é€šçŸ¥æƒé™
        const requestNotificationPermission = () => {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        };

        // å¯¼èˆªå‡½æ•°
        const navigateTo = (url) => {
            window.location.href = url;
        };

        // æ ‡è®°ä¸ºå·²è¯»
        const markOrdersAsRead = () => {
            hasNewOrders.value = false;
            unreadOrdersCount.value = 0;
        };

        // æ·»åŠ èœå“
        const addDish = () => {
            dishFormRef.value.validate(async (valid) => {
                if (valid) {
                    addLoading.value = true;
                    try {
                        const response = await fetch('/api/merchant/dishes/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCookie('csrftoken')
                            },
                            body: JSON.stringify({
                                action: 'add',
                                name: newDish.value.name,
                                price: parseFloat(newDish.value.price),
                                description: newDish.value.description
                            })
                        });
                        
                        const data = await response.json();
                        if (data.success) {
                            ElMessage.success('æ·»åŠ èœå“æˆåŠŸ');
                            showAddDialog.value = false;
                            newDish.value = { name: '', price: 0, description: '' };
                            await loadDishes();
                        } else {
                            ElMessage.error('æ·»åŠ èœå“å¤±è´¥: ' + data.error);
                        }
                    } catch (error) {
                        console.error('æ·»åŠ èœå“é”™è¯¯:', error);
                        ElMessage.error('æ·»åŠ èœå“å¤±è´¥');
                    } finally {
                        addLoading.value = false;
                    }
                }
            });
        };

        const toggleDishStatus = async (dish) => {
            try {
                const response = await fetch('/api/merchant/dishes/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        action: 'update',
                        id: dish.id,
                        name: dish.name,
                        price: parseFloat(dish.price),
                        description: dish.description,
                        is_available: !dish.is_available
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    ElMessage.success(`èœå“å·²${!dish.is_available ? 'ä¸Šæ¶' : 'ä¸‹æ¶'}`);
                    await loadDishes();
                } else {
                    ElMessage.error('æ›´æ–°èœå“çŠ¶æ€å¤±è´¥: ' + data.error);
                }
            } catch (error) {
                console.error('æ›´æ–°èœå“çŠ¶æ€é”™è¯¯:', error);
                ElMessage.error('æ›´æ–°èœå“çŠ¶æ€å¤±è´¥');
            }
        };

        const deleteDish = async (dishId) => {
            try {
                await ElMessageBox.confirm(
                    'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªèœå“å—ï¼Ÿ',
                    'æç¤º',
                    {
                        confirmButtonText: 'ç¡®å®š',
                        cancelButtonText: 'å–æ¶ˆ',
                        type: 'warning',
                    }
                );
                
                const response = await fetch('/api/merchant/dishes/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        action: 'delete',
                        id: dishId
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    ElMessage.success('åˆ é™¤èœå“æˆåŠŸ');
                    await loadDishes();
                } else {
                    ElMessage.error('åˆ é™¤èœå“å¤±è´¥: ' + data.error);
                }
            } catch (error) {
                if (error !== 'cancel') {
                    console.error('åˆ é™¤èœå“é”™è¯¯:', error);
                    ElMessage.error('åˆ é™¤èœå“å¤±è´¥');
                }
            }
        };

        const getCookie = (name) => {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        };

        // åˆå§‹åŒ–
        onMounted(() => {
            loadDishes();
            loadMerchantOrders();
            requestNotificationPermission();
            
            // æ¯10ç§’åˆ·æ–°ä¸€æ¬¡è®¢å•
            setInterval(() => {
                loadMerchantOrders();
            }, 10000);
        });

        return {
            dishes,
            orders,
            showAddDialog,
            addLoading,
            dishFormRef,
            newDish,
            dishRules,
            availableDishesCount,
            todayOrdersCount,
            pendingOrdersCount,
            hasNewOrders,
            unreadOrdersCount,
            loadDishes,
            addDish,
            toggleDishStatus,
            deleteDish,
            navigateTo,
            markOrdersAsRead,
            getCookie
        };
    }
}).use(ElementPlus).mount('#appmerchant');

</script>


{% endblock %}